```markdown
# メモリマップトストレージ

Codanna はメモリマップトファイルを用いて即時ロードと高性能アクセスを実現します。

## 2 段キャッシュアーキテクチャ

アクセスパターンの違いに応じて、キャッシュ設計も異なります。

### シンボルキャッシュ (`symbol_cache.bin`)
- **目的**: 名前による高速シンボル検索
- **ハッシュ**: 分布のため FNV-1a を使用
- **アクセス**: <10ms の応答時間
- **サイズ**: シンボルあたり約 100 バイト
- **ストレージ**: コンパクトなシンボル表現

### ベクターキャッシュ (`segment_0.vec`)
- **目的**: セマンティック類似度検索
- **次元数**: モデルにより 384/768/1024 を設定可能
- **アクセス**: OS ページキャッシュが温まった後 <1μs
- **ストレージ**: バイナリパックされた浮動小数点配列
- **構成**: 高速検索のため IVFFlat クラスタリング

## メモリマップトの利点

### 即時起動
- ロード時のデシリアライズ不要
- OS がファイルを直接メモリにマッピング
- アプリケーションからは通常のメモリとして見える
- 最初のアクセス時にページがロードされる

### 効率的なメモリ使用
- OS がページングを自動管理
- 非アクティブページはスワップアウト可能
- 複数プロセスで同一物理メモリを共有
- 手動キャッシュ管理不要

### 永続性
- データは実行間で保持
- 再起動時の再構築不要
- アトミック書き込みにより破損を防止
- 耐久性はファイルシステムが担保

## シンボルキャッシュ構造

```rust
struct CompactSymbol {
    id: NonZeroU32,           // 4 bytes
    kind: u8,                 // 1 byte
    file_id: NonZeroU32,      // 4 bytes
    range: CompactRange,      // 8 bytes (start/end)
    name_hash: u64,           // 8 bytes (FNV-1a)
    flags: u8,                // 1 byte
    // Total: 26 bytes + padding = 32 bytes (cache-line aligned)
}
```

**キャッシュラインアラインメント**: 1 シンボル 32 バイト、64 バイトのキャッシュラインに 2 シンボル配置。

## ベクターキャッシュ構造

```
segment_0.vec:
├── Header (metadata)
│   ├── Model name
│   ├── Dimensions
│   ├── Vector count
│   └── Cluster count
├── Cluster metadata
│   ├── Cluster centroids
│   └── Cluster boundaries
└── Vector data
    ├── Vector 0: [f32; dimensions]
    ├── Vector 1: [f32; dimensions]
    └── ...
```

**ストレージ形式**: `bincode` によるバイナリパックされた f32 配列。

## IVFFlat クラスタリング

ベクターは Inverted File with Flat vectors を用いて整理されます。

1. **K-means クラスタリング**で類似ベクターをグループ化  
2. **セントロイド**が各クラスタを代表  
3. **検索**は近傍クラスタを優先  
4. **比較数を** N から ~√N に削減  

10,000 ベクターの例:
- クラスタリングなし: 10,000 比較
- 100 クラスタ: 約 1,000 比較（10 倍高速）

## キャッシュウォーミング

最初のアクセスで OS キャッシュにページをロード:

```
Cold start: 100-200ms (ディスクからロード)
Warm cache: <1μs (RAM 内)
```

**ホットパスはすぐウォームアップ** — 頻繁なクエリは OS キャッシュの恩恵を受けます。

## 書き込み操作

### シンボルキャッシュの更新
1. 新しいシンボルキャッシュをメモリ上で構築  
2. 一時ファイルに書き込み  
3. `symbol_cache.bin` へアトミックリネーム  
4. 次回アクセス時に OS がメモリを再マップ  

### ベクターキャッシュの更新
1. 新しい埋め込みを生成  
2. K-means でベクターを再クラスタリング  
3. 新しいセグメントファイルを書き込み  
4. 旧ベクターを削除  
5. メタデータを更新  

**クラッシュセーフティ**: 新ファイル完了まで旧ファイルは有効。

## ストレージレイアウト

```
.codanna/index/
├── symbol_cache.bin        # FNV-1a ハッシュ済みシンボル
└── vectors/
    ├── segment_0.vec       # ベクターデータ
    ├── segment_1.vec       # (必要に応じて)
    ├── metadata.bin        # インデックスメタデータ
    └── clusters.bin        # クラスタ情報
```

## メモリ要件

シンボル 100,000 件のプロジェクトの場合:

**シンボルキャッシュ:**
- 100,000 × 32 バイト = 3.2 MB

**ベクターキャッシュ (384 次元モデル):**
- 100,000 × 384 浮動小数 × 4 バイト = 153.6 MB

**合計:** 約 157 MB (OS オーバーヘッド除く)

## スケーラビリティ

メモリマップトファイルは以下にスケール可能:
- 数百万シンボル
- 数ギガバイトのベクターデータ
- 複数同時リーダー
- ページングは OS が自動処理

## パフォーマンス特性

### 読み取り性能
- シンボル検索: FNV-1a で O(1)
- ベクター検索: IVFFlat で O(√N)
- シリアライズオーバーヘッドなし
- キャッシュラインアライン済みアクセス

### 書き込み性能
- バッチ更新推奨
- アトミックファイル置換
- リーダーにロック不要
- バックグラウンド再クラスタリング

## ゼロコピー・デシリアライズ

`rkyv` を使用:
- ロード時のパース不要
- メモリを直接アクセス
- 型安全な操作
- 即時利用可能

## トラブルシューティング

### 高メモリ使用量
- OS はファイル全体をマップするが全てをロードしない
- `vmstat` で実際の RAM 使用量を確認
- 非アクティブページは自然にスワップ

### 最初の検索が遅い
- OS がディスクからページをロード
- 2 回目以降は高速
- `cat .codanna/index/vectors/segment_0.vec > /dev/null` で事前ウォーム可能

### 破損復旧
- 破損したキャッシュファイルを削除
- `codanna index` を再実行して再構築
- アトミック書き込みにより部分更新を防止

## 参考

- [仕組み](how-it-works.md) - システム概要
- [埋め込みモデル](embedding-model.md) - ベクター生成
- [パフォーマンス](../advanced/performance.md) - 最適化ヒント
```